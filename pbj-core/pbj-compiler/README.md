# PBJ Protobuf Schema Compiler Gradle Plugin

A Gradle plugin that compiles protobuf schema files into Java model objects, codecs, and unit tests. The plugin takes
all `.proto` schema files in a project in the `src/main/proto` directory and generates Java code in the
`build/generated.source/pbj-proto` directory. The generated code is then compiled and tested as part of the project
build.

## Usage

### Apply the plugin

Add the following to your `build.gradle` file to apply the plugin:

```kotlin
plugins {
    id("com.hedera.pbj.pbj-compiler")
}
```

### Configure the plugin

The plugin has the following configuration of included src directories:

```kotlin
sourceSets {
    main {
        pbj {
            srcDir(...)
        }
    }
}
```

## Build Libraries

Running `gradle build` in `pbj-core` directory will build the libraries for compiler and runtime to produce
`hedera.pbj-compiler.gradle.plugin-VERSION.jar`

## Records vs Classes

The generated model objects are Java Classes, they used to be Java Records. This is a very tough decision and there are
many trade-offs. The main reason for the change is that Java Records have no way to have lazy computed final fields. We
need to lazy compute and cache the hashCode() and protobufSize() values, otherwise the performance impact is huge. In
hiero use cases, not all model objects will have hashCode or protobufSize called on them so we need to avoid the cost of
computing if not needed. Also, it is very costly to compute values in the constructor and store them in a final field as the thread that
constructs the model object is performance critical; these costs can be moved to background threads with lazy compute. When we get
to Java versions with support for "[JEP 401: Value Classes and Objects](https://openjdk.org/jeps/401)" we will need to
review this decision. It may be better performance to compute in the constructor then so that model objects can be value objects
and exist on stack rather than heap. It is also possible there will be a heuristic to choose which classes are processed one way
or the other. Alternatively, we may add an option in schema to choose the implementation on a message-by-message basis.

## PBJ Package Config Option

In the `.proto` file you must add a special formatted comment as follows:

```
// <<<pbj.java_package = "com.company.proto.package";>>>
```

This is for setting a different Java package for the generated code form the one used by default `protoc` compiler. This
is needed so all messages can be generated by both PBJ and `protoc` and the classes will not clash. Both are needed by
unit tests that validate the binary wire encoding is identical between the two. For example, we might have 3 packages
defined in a schema. One for the `.proto` space, one for `protoc` generated Java code, and one for PBJ generated Java
code.

```protobuf
package com.hedera.pbj;
option java_package = "com.hedera.pbj.test.proto.java";
// <<<pbj.java_package = "com.hedera.pbj.test.proto.pbj">>>
```

It was done as a comment as it is not a standard protobuf option and so will not be understood by the `protoc` compiler.

## Generated Model Objects

Each protobuf message is generated into a Java Class model object. With static instances for two codecs and a default
value. There is an inner `Builder` class generated for fluid style building of the model object. There is also a
`copyBuilder()` method that lets you easily create a derivative of this immutable record with some changes.

#### Protobuf Message Example

```protobuf
message Fraction {
    int64 numerator = 1;
    int64 denominator = 2;
}
```

#### Example generated model Java class

This is just a simplified example of the generated code. The actual generated code is more complex and has more
documentation. But this should give you an idea of the public API.

```java
public final class Fraction {
    // protobuf and json codecs
    public static final Codec<Fraction> PROTOBUF = new com.hedera.hapi.node.base.codec.FractionProtoCodec();
    public static final JsonCodec<Fraction> JSON = new com.hedera.hapi.node.base.codec.FractionJsonCodec();
    // default value
    public static final Fraction DEFAULT = newBuilder().build();

    // private final fields
    private final long numerator;
    private final long denominator;

    // constructor and getters
    public Fraction(long numerator, long denominator) {...}
    public long seconds() { return seconds; }
    public int nanos() { return nanos; }

    // builder
    public Builder copyBuilder() {...}
    public static Builder newBuilder() {...}
    public static final class Builder {...}

    // generated methods
    public int protobufSize() {...}
    public int hashCode() {...}
    public boolean equals(Object that) {...}
    public String toString() {...}
}
```

### Generated Codecs in `codec` sub-package

Codecs are generated for each model class, one for Protobuf binary encoding and one for Protobuf JSON encoding. There
are static instances accessible via `MyModelOject.PROTOBUF` and `MyModelOject.JSON`.

### Generated Schemas in `scehma` sub-package

The generated code includes the schema class for each model object that provides programmatic information on the
messages fields and their types. This is used by the codecs to encode and decode the messages. It could be useful for
other use cases in the future.

### Generated Builders

A builder class is generated for each model object that provides a fluent API for building the model object. There are
two static convenience methods generated `MyModelObject.newBuilder()` and `MyModelObject.copyBuilder()`. The
`copyBuilder()` provides an easy way to create a modified version of this model object as the model objects are
immutable.

### Generated Unit Tests

For each generated model object there is a unit test generated that tests the protobuf and JSON codecs against the
*protoc* generated code to make sure they are 100% byte for byte binary compatible. This requires a dependency on
Google Protobuf libraries which may not be always desirable. To disable tests generation and avoid having to add
a dependency on Google Protobuf libraries, add the following configuration to your `build.gradle.kts`:

```kotlin
pbj {
   generateTestClasses = false
}
```

## Generated Code Formatting

The generated code is formatted with clean indenting and comments, just like you would write by hand. Engineers working
on the compiler should put the effort in to keep generated code clean. A future option might be to add a post-processing
step with spotless, or similar, to auto format generated code.
