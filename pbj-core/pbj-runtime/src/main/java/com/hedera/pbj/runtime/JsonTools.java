// SPDX-License-Identifier: Apache-2.0
package com.hedera.pbj.runtime;

import com.hedera.pbj.runtime.io.WritableSequentialData;
import com.hedera.pbj.runtime.io.buffer.Bytes;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.util.Base64;
import java.util.List;
import java.util.Map;

/**
 * Class of static utility methods for working with JSON. All generated JSON is designed to be
 * 100% identical to that generated by Google Protobuf library.
 */
@SuppressWarnings("ForLoopReplaceableByForEach")
public final class JsonTools {

    // ====================================================================================================
    // Conversion Utility Methods

    /**
     * Convert a protobuf field name to a protobuf spec json field name. This is based directly on the code
     * from protobuf library so that it matches exactly.
     *
     * @param fieldName the protobuf field name to convert
     * @return the protobuf spec json field name
     */
    public static String toJsonFieldName(String fieldName) {
        // based directly on protoc so output matches
        final int length = fieldName.length();
        StringBuilder result = new StringBuilder(length);
        boolean isNextUpperCase = false;
        for (int i = 0; i < length; i++) {
            char ch = fieldName.charAt(i);
            if (ch == '_') {
                isNextUpperCase = true;
            } else if (isNextUpperCase) {
                // This closely matches the logic for ASCII characters in:
                // http://google3/google/protobuf/descriptor.cc?l=249-251&rcl=228891689
                if ('a' <= ch && ch <= 'z') {
                    ch = (char) (ch - 'a' + 'A');
                }
                result.append(ch);
                isNextUpperCase = false;
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    /**
     * Unescape a string that was escaped by replacing new lines with \n or \r.
     *
     * @param string the string with escapes to unescape
     * @return the unescaped string, null if input string is null
     */
    public static String unescape(@Nullable String string) {
        if (string == null) return null;
        return string.replaceAll("\\\\n", "\n").replaceAll("\\\\r", "\r");
    }

    public static final byte OPEN_OBJECT = '{';
    public static final byte CLOSE_OBJECT = '}';
    public static final byte OPEN_ARRAY = '[';
    public static final byte CLOSE_ARRAY = ']';
    public static final byte NL = '\n';
    public static final byte SPACE = ' ';
    public static final byte COLON = ':';
    public static final byte COMMA = ',';
    public static final byte n = 'n';
    public static final byte u = 'u';
    public static final byte l = 'l';

    // ====================================================================================================
    // To JSON String Methods

    /**
     * Object field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static <T> void field(@NonNull WritableSequentialData out, int indent, String fieldName, JsonCodec<T> codec, @Nullable final T value) {
        out.writeJsonString(toJsonFieldName(fieldName), true);
        out.writeByte2(COLON, SPACE);
        if (value != null) {
            codec.write(value, out, 0, 2, true); // TODO replace indent.length with indent
        } else {
            out.writeByte4(n,u,l,l);
        }
    }

    /**
     * String field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, String value) {
        out.writeJsonString(fieldName, true);
        out.writeByte2(COLON, SPACE);
        out.writeJsonString(value, true);
    }
    
    /**
     * String field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void fieldUnquoted(@NonNull WritableSequentialData out, String fieldName, String value) {
        out.writeJsonString(fieldName, true);
        out.writeByte2(COLON, SPACE);
        out.writeJsonString(value, false);
    }

    /**
     * String field to JSON string
     *
     * @param fieldName the name of the field
     */
    public static void fieldNull(@NonNull WritableSequentialData out, String fieldName) {
        out.writeJsonString(fieldName, true);
        out.writeByte2(COLON, SPACE);
        out.writeByte4(n,u,l,l);
    }

    /**
     * Bytes field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Bytes value) {
        String rawValue = value.toBase64();
        field(out, fieldName, rawValue);
    }

    /**
     * Byte array field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, byte[] value) {
        String rawValue = Base64.getEncoder().encodeToString(value);
        field(out, fieldName, rawValue);
    }

    /**
     * Map field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @param vComposer a composer of a "key":value strings - basically, a JsonTools::field method for the value type
     */
    public static <K, V> void field(@NonNull WritableSequentialData out,
            String fieldName, Map<K, V> value, FieldFunction<V> vComposer) {
        assert !value.isEmpty();
        out.writeJsonString(fieldName, true);
        out.writeByte4(COLON, SPACE, OPEN_OBJECT, NL);
        PbjMap<K, V> pbjMap = (PbjMap<K, V>) value;
        for (int i = 0; i < pbjMap.size(); i++) {
            if (i > 0) {
                out.writeByte2(COMMA, NL);
            }
            K k = pbjMap.getSortedKeys().get(i);
            V v = pbjMap.get(k);

//            String keyStr = kEncoder.apply(k); // TODO: implement a key encoder
            vComposer.write(out, k.toString(), v); // TODO pass in indent
        }
        out.writeByte(CLOSE_OBJECT);
    }

    public interface FieldFunction<T> {
        void write(@NonNull WritableSequentialData out, String fieldName, T value);
    }

    /**
     * Primitive boolean field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, boolean value) {
        fieldUnquoted(out, fieldName, value ? "true" : "false");
    }

    /**
     * Primitive int field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, int value) {
        fieldUnquoted(out, fieldName, Integer.toString(value));
    }

    /**
     * Primitive long field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, long value) {
        field(out, fieldName, Long.toString(value));
    }

    /**
     * Primitive float field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, float value) {
        if (Float.isNaN(value)) {
            field(out, fieldName, "NaN");
        } else if (Float.isInfinite(value)) {
            field(out, fieldName, value < 0 ? "-Infinity" : "Infinity");
        } else {
            field(out, fieldName, Float.toString(value));
        }
    }

    /**
     * Primitive double field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, double value) {
        if (Double.isNaN(value)) {
            field(out, fieldName, "NaN");
        } else if (Double.isInfinite(value)) {
            field(out, fieldName, value < 0 ? "-Infinity" : "Infinity");
        } else {
            field(out, fieldName, Double.toString(value));
        }
    }

    /**
     * Boxed Boolean field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Boolean value) {
        if (value == null) {
            fieldNull(out, fieldName);
        } else {
            fieldUnquoted(out, fieldName, value.toString());
        }
    }

    /**
     * Boxed Integer field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Integer value) {
        if (value == null) {
            fieldNull(out, fieldName);
        } else {
            field(out, fieldName, value.intValue());
        }
    }

    /**
     * Boxed Long field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Long value, boolean quote) {
        if (value == null) {
            fieldNull(out, fieldName);
        } else if (quote) {
            field(out, fieldName, Long.toString(value));
        } else {
            fieldUnquoted(out, fieldName, Long.toString(value));
        }
    }

    /**
     * Boxed Float field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Float value) {
        if (value == null) {
            fieldNull(out, fieldName);
        } else {
            field(out, fieldName, value.floatValue());
        }
    }

    /**
     * Boxed Double field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, String fieldName, Double value) {
        if (value == null) {
            fieldNull(out, fieldName);
        } else {
            field(out, fieldName, value.doubleValue());
        }
    }

    /**
     * Array field of primitives to JSON string
     *
     * @param fieldName the name of the field
     * @param items the items in the array
     * @param <T> the type of the items in the array
     */
    public static <T> void arrayField(@NonNull WritableSequentialData out, String fieldName, FieldDefinition fieldDefinition, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                out.writeJsonString(fieldName, true);
                out.writeByte4(COLON, SPACE, OPEN_ARRAY, CLOSE_ARRAY);
            } else {
                out.writeJsonString(fieldName, true);
                out.writeByte3(COLON, SPACE, OPEN_ARRAY);
                boolean isFirst = true;
                for (int i = 0; i < items.size(); i++) {
                    final T item = items.get(i);
                    if (isFirst) {
                        isFirst = false;
                    } else {
                        out.writeByte2(COMMA, SPACE);
                    }
                    if (fieldDefinition.optional() && item == null) {
                        out.writeByte4(n,u,l,l);
                    } else {
                        switch (fieldDefinition.type()) {
                            case STRING -> out.writeJsonString((String) item, true);
                            case BYTES -> out.writeJsonString(((Bytes) item).toBase64(), true);
                            case INT32, SINT32, UINT32, FIXED32, SFIXED32 ->
                                    out.writeJsonString(Integer.toString((Integer) item), false);
                            case INT64, SINT64, UINT64, FIXED64, SFIXED64 ->
                                    out.writeJsonString(Long.toString((Long) item), true);
                            case FLOAT -> out.writeJsonString(Float.toString((Float) item), true);
                            case DOUBLE -> out.writeJsonString(Double.toString((Double) item), true);
                            case BOOL -> out.writeJsonString(Boolean.toString((Boolean) item), false);
                            case ENUM -> out.writeJsonString(((EnumWithProtoMetadata) item).protoName(), true);
                            case MESSAGE -> throw new UnsupportedOperationException(
                                    "No expected here should have called other arrayField() method");
                            case MAP -> throw new UnsupportedOperationException("Arrays of maps not supported");
                        }
                    }
                }
                out.writeByte(CLOSE_ARRAY);
            }
        }
    }

    /**
     * Array field of objects to JSON string
     *
     * @param indent the indent to use for generated JSON
     * @param fieldName the name of the field
     * @param codec the codec to use for encoding the items
     * @param items the items in the array
     * @param <T> the type of the items in the array
     */
    public static <T> void arrayField(@NonNull WritableSequentialData out, int indent, String fieldName, JsonCodec<T> codec, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                fieldUnquoted(out, fieldName, "[]");
            } else {
                out.writeJsonString(toJsonFieldName(fieldName), true);
                out.writeByte3(COLON, SPACE, OPEN_ARRAY);
                for (int i = 0; i < items.size(); i++) {
                    var item = items.get(i);
                    codec.write(item, out, indent, 2, true); // TODO replace 0, 2 with indent
                    if (i < items.size() - 1) {
                        out.writeByte2(COMMA, SPACE);
                    }
                }
                out.writeByte(CLOSE_ARRAY);
            }
        }
    }
}
