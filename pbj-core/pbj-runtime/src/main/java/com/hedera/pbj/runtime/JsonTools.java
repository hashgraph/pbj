package com.hedera.pbj.runtime;

import com.hedera.pbj.runtime.io.ReadableSequentialData;
import com.hedera.pbj.runtime.io.buffer.Bytes;
import com.hedera.pbj.runtime.jsonparser.JSONLexer;
import com.hedera.pbj.runtime.jsonparser.JSONParser;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Class of static utility methods for working with JSON. All generated JSON is designed to be
 * 100% identical to that generated by Google Protobuf library.
 */
public final class JsonTools {
    /** The indent spacing to use for pretty printing JSON */
    public static final String INDENT = "  ";

    public static String toJsonFieldName(String fieldName) {
        // based directly on protoc so output matches
        final int length = fieldName.length();
        StringBuilder result = new StringBuilder(length);
        boolean isNextUpperCase = false;
        for (int i = 0; i < length; i++) {
            char ch = fieldName.charAt(i);
            if (ch == '_') {
                isNextUpperCase = true;
            } else if (isNextUpperCase) {
                // This closely matches the logic for ASCII characters in:
                // http://google3/google/protobuf/descriptor.cc?l=249-251&rcl=228891689
                if ('a' <= ch && ch <= 'z') {
                    ch = (char) (ch - 'a' + 'A');
                }
                result.append(ch);
                isNextUpperCase = false;
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    public static <T> List<T> parseObjArray(JSONParser.ArrContext arrContext, JsonCodec<T> codec) {
        return arrContext.value().stream()
                .map(v -> {
                    try {
                        return codec.parse(v.obj(), false);
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                }).toList();
    }

    public static int parseInteger(JSONParser.ValueContext valueContext) {
        return Integer.parseInt(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    public static long parseLong(JSONParser.ValueContext valueContext) {
        return Long.parseLong(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    public static float parseFloat(JSONParser.ValueContext valueContext) {
        return Float.parseFloat(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    public static double parseDouble(JSONParser.ValueContext valueContext) {
        return Double.parseDouble(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }
    public static boolean parseBoolean(JSONParser.ValueContext valueContext) {
        return Boolean.parseBoolean(valueContext.getText());
    }

    public static JSONParser.ObjContext parseJson(@NonNull final ReadableSequentialData input) throws IOException {
        final JSONLexer lexer = new JSONLexer(CharStreams.fromStream(input.asInputStream()));
        final JSONParser parser = new JSONParser(new CommonTokenStream(lexer));
        final JSONParser.JsonContext jsonContext = parser.json();
        final JSONParser.ValueContext valueContext = jsonContext.value();
        return  valueContext.obj();
    }

    /**
     * Unescape a string that was escaped by replacing new lines with \n or \r.
     *
     * @param string the string with escapes to unescape
     * @return the unescaped string, null if input string is null
     */
    public static String unescape(@Nullable String string) {
        if (string == null) return null;
        return string.replaceAll("\\\\n", "\n").replaceAll("\\\\r", "\r");
    }

    /**
     * Escape a string by replacing new lines with \n or \r.
     *
     * @param string the string to escape
     * @return the escaped string, null if input string is null
     */
    public static String escape(@Nullable String string) {
        if (string == null) return null;
        return string.replaceAll("\n","\\\\n").replaceAll("\r","\\\\r");
    }

    private static String rawFieldCode(String fieldName, String rawValue) {
        return '"' + fieldName + '"' + ": " + rawValue;
    }

    public static <T> String field(String indent, String fieldName,
                                 JsonCodec<T> codec, @Nullable final T value) {
        if (value != null) {
            return '"' + toJsonFieldName(fieldName) + '"' + ": " +
                    codec.toJSON(value, indent, true);
        } else {
            return '"' + toJsonFieldName(fieldName) + '"' + ": null";
        }
    }

    public static String field(String fieldName, boolean value) {
        return rawFieldCode(fieldName, value ? "true" : "false");
    }

    public static String field(String fieldName, String value) {
        return rawFieldCode(fieldName, '"' + escape(value) + '"');
    }

    public static String field(String fieldName, Bytes value) {
        return rawFieldCode(fieldName, '"' + value.toBase64() + '"');
    }

    public static String field(String fieldName, byte[] value) {
        return rawFieldCode(fieldName, '"' + Base64.getEncoder().encodeToString(value) + '"');
    }

    public static String field(String fieldName, int value) {
        return rawFieldCode(fieldName, Integer.toString(value));
    }

    public static String field(String fieldName, long value) {
        return rawFieldCode(fieldName, '"' + Long.toString(value) + '"');
    }

    public static String field(String fieldName, float value) {
        if (Float.isNaN(value)) {
            return rawFieldCode(fieldName, "\"NaN\"");
        } else if (Float.isInfinite(value)) {
            return rawFieldCode(fieldName, "\""+(value < 0 ? "-Infinity" : "Infinity")+"\"");
        } else {
            return rawFieldCode(fieldName,  Float.toString(value) );
        }
    }

    public static String field(String fieldName, double value) {
        if (Double.isNaN(value)) {
            return rawFieldCode(fieldName, "\"NaN\"");
        } else if (Double.isInfinite(value)) {
            return rawFieldCode(fieldName, "\""+(value < 0 ? "-Infinity" : "Infinity")+"\"");
        } else {
            return rawFieldCode(fieldName, Double.toString(value));
        }
    }

    public static String field(String fieldName, Boolean value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return rawFieldCode(fieldName, Boolean.toString(value));
        }
    }
    public static String field(String fieldName, Integer value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return rawFieldCode(fieldName, Integer.toString(value));
        }
    }
    public static String field(String fieldName, Long value, boolean quote) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else if(quote) {
            return rawFieldCode(fieldName, '\"' + Long.toString(value) + '\"');
        } else {
            return rawFieldCode(fieldName, Long.toString(value));
        }
    }

    public static String field(String fieldName, Float value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return field(fieldName, value.floatValue());
        }
    }

    public static String field(String fieldName, Double value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return field(fieldName, value.doubleValue());
        }
    }


    public static <T> String arrayField(String fieldName,
                                      FieldDefinition fieldDefinition, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                return rawFieldCode(fieldName, "[]");
            } else {
                String values = items.stream()
                        .map(item -> {
                            if (fieldDefinition.optional() && item == null) {
                                return "\"null\"";
                            } else {
                                return switch (fieldDefinition.type()) {
                                    case STRING -> '"' + escape((String) item) + '"';
                                    case BYTES -> '"' + ((Bytes) item).toBase64() + '"';
                                    case INT32, SINT32, UINT32, FIXED32, SFIXED32 -> Integer.toString((Integer) item);
                                    case INT64, SINT64, UINT64, FIXED64, SFIXED64 -> '"' + Long.toString((Long) item) + '"';
                                    case FLOAT -> Float.toString((Float) item);
                                    case DOUBLE -> Double.toString((Double) item);
                                    case BOOL -> Boolean.toString((Boolean) item);
                                    case ENUM -> '"' + ((EnumWithProtoMetadata)item).protoName() + '"';
                                    case MESSAGE -> throw new UnsupportedOperationException("No expected here should have called other arrayField() method");
                                };
                            }
                        })
                        .collect(Collectors.joining(", "));
                return rawFieldCode(fieldName, "["+values+"]");
            }
        }
        return null;
    }

    public static <T> String arrayField(String indent, String fieldName,
                                      JsonCodec<T> codec, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                return rawFieldCode(fieldName, "[]");
            } else {
                StringBuilder code = new StringBuilder('"' + fieldName + '"' + ": [");
                for (int i = 0; i < items.size(); i++) {
                     var item = items.get(i);
                    code.append(codec.toJSON(item, indent, true));
                    if (i < items.size() - 1) {
                        code.append(", ");
                    }
                }
                code.append("]");
                return code.toString();
            }
        }
        return null;
    }

}
