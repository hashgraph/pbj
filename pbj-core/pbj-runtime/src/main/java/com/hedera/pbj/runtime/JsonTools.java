// SPDX-License-Identifier: Apache-2.0
package com.hedera.pbj.runtime;

import com.hedera.pbj.runtime.io.WritableSequentialData;
import com.hedera.pbj.runtime.io.buffer.Bytes;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.Map;

/**
 * Class of static utility methods for working with JSON. All generated JSON is designed to be
 * 100% identical to that generated by Google Protobuf library.
 */
@SuppressWarnings({"ForLoopReplaceableByForEach"})
public final class JsonTools {
    public static final byte OPEN_OBJECT = '{';
    public static final byte CLOSE_OBJECT = '}';
    public static final byte OPEN_ARRAY = '[';
    public static final byte CLOSE_ARRAY = ']';
    public static final byte NL = '\n';
    public static final byte SPACE = ' ';
    public static final byte COMMA = ',';
    public static final byte QUOTE = '"';
    public static final byte MINUS = '-';
    public static final byte n = 'n';
    public static final byte u = 'u';
    public static final byte l = 'l';
    public static final byte _0 = '0';
    private static final byte[] _TRUE = "true".getBytes(StandardCharsets.UTF_8);
    private static final byte[] _FALSE = "false".getBytes(StandardCharsets.UTF_8);
    private static final byte[] SPACES = new byte[128];
    static {
        Arrays.fill(SPACES, SPACE);
    }

    // ====================================================================================================
    // To JSON String Methods

    public static void writeIndent(@NonNull WritableSequentialData out, int indent) {
        if (indent > 0) {
            out.writeBytes(SPACES, 0, indent);
        }
    }

    /**
     * Object field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static <T> void field(@NonNull WritableSequentialData out, int indent, byte[] fieldNameBytes, JsonCodec<T> codec, @Nullable final T value) {
        out.writeBytes(fieldNameBytes);
        if (value != null) {
            codec.write(value, out, indent, 2, false); // TODO replace indent.length with indent
        } else {
            out.writeByte4(n,u,l,l);
        }
    }

    /**
     * String field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, String value) {
        out.writeBytes(fieldNameBytes);
        out.writeJsonString(value, true);
    }

    /**
     * String field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     */
    public static void fieldNull(@NonNull WritableSequentialData out, byte[] fieldNameBytes) {
        out.writeBytes(fieldNameBytes);
        out.writeByte4(n,u,l,l);
    }

    /**
     * Bytes field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Bytes value) {
        out.writeBytes(fieldNameBytes);
        out.writeByte(QUOTE);
        out.writeBase64(value);
        out.writeByte(QUOTE);
    }

    /**
     * Byte array field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, byte[] value) {
        String rawValue = Base64.getEncoder().encodeToString(value);
        out.writeBytes(fieldNameBytes);
        out.writeJsonString(rawValue, true);
    }

    /**
     * Map field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param indent the indent to use for generated JSON
     * @param value the value of the field
     * @param vComposer a composer of a "key":value strings - basically, a JsonTools::field method for the value type
     */
    public static <K, V> void field(@NonNull WritableSequentialData out,
            int indent, byte[] fieldNameBytes, Map<K, V> value, FieldFunction<V> vComposer) {
        assert !value.isEmpty();
        out.writeBytes(fieldNameBytes);
        out.writeByte2(OPEN_OBJECT, NL);
        PbjMap<K, V> pbjMap = (PbjMap<K, V>) value;
        for (int i = 0; i < pbjMap.size(); i++) {
            if (i > 0) {
                out.writeByte2(COMMA, NL);
            }
            writeIndent(out, indent);
            K k = pbjMap.getSortedKeys().get(i);
            V v = pbjMap.get(k);
            final String kStr = '"' + k.toString()
                    .replaceAll("\"", "\\\\\"")
                    .replaceAll("\n", "\\\\n")
                    .replaceAll("\r", "\\\\r")
                    .replaceAll("\t", "\\\\t")
                    .replaceAll("\f", "\\\\f")
                    .replaceAll("\b", "\\\\b")
                    .replaceAll("\\\\", "\\\\") + "\": ";
//            String keyStr = kEncoder.apply(k); // TODO: implement a key encoder
            vComposer.write(out, kStr.getBytes(StandardCharsets.UTF_8), v); // TODO pass in indent
        }
        out.writeByte(NL);
        writeIndent(out, indent - 2);
        out.writeByte(CLOSE_OBJECT);
    }

    public interface FieldFunction<T> {
        void write(@NonNull WritableSequentialData out, byte[] fieldNameBytes, T value);
    }

    /**
     * Primitive boolean field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, boolean value) {
        out.writeBytes(fieldNameBytes);
        out.writeBytes(value ? _TRUE : _FALSE);
    }

    /**
     * Primitive int field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, int value) {
        out.writeBytes(fieldNameBytes);
        out.writeJsonLong(value, false);
    }

    /**
     * Primitive long field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, long value) {
        out.writeBytes(fieldNameBytes);
        out.writeJsonLong(value, true);
    }

    /**
     * Primitive float field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, float value) {
        if (Float.isNaN(value)) {
            out.writeBytes(fieldNameBytes);
            out.writeJsonString("NaN", true);
        } else if (Float.isInfinite(value)) {
            String value1 = value < 0 ? "-Infinity" : "Infinity";
            out.writeBytes(fieldNameBytes);
            out.writeJsonString(value1, true);
        } else {
            String value1 = Float.toString(value);
            out.writeBytes(fieldNameBytes);
            out.writeJsonString(value1, false);
        }
    }

    /**
     * Primitive double field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, double value) {
        if (Double.isNaN(value)) {
            out.writeBytes(fieldNameBytes);
            out.writeJsonString("NaN", true);
        } else if (Double.isInfinite(value)) {
            String value1 = value < 0 ? "-Infinity" : "Infinity";
            out.writeBytes(fieldNameBytes);
            out.writeJsonString(value1, true);
        } else {
            String value1 = Double.toString(value);
            out.writeBytes(fieldNameBytes);
            out.writeJsonString(value1, false);
        }
    }

    /**
     * Boxed Boolean field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Boolean value) {
        if (value == null) {
            fieldNull(out, fieldNameBytes);
        } else {
            out.writeBytes(fieldNameBytes);
            out.writeBytes(value ? _TRUE : _FALSE);
        }
    }

    /**
     * Boxed Integer field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Integer value) {
        if (value == null) {
            fieldNull(out, fieldNameBytes);
        } else {
            field(out, fieldNameBytes, value.intValue());
        }
    }

    /**
     * Boxed Long field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Long value, boolean quote) {
        if (value == null) {
            fieldNull(out, fieldNameBytes);
        } else if (quote) {
            out.writeBytes(fieldNameBytes);
            out.writeJsonString(Long.toString(value), true);
        } else {
            field(out, fieldNameBytes, Long.toString(value));
        }
    }

    /**
     * Boxed Float field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Float value) {
        if (value == null) {
            fieldNull(out, fieldNameBytes);
        } else {
            field(out, fieldNameBytes, value.floatValue());
        }
    }

    /**
     * Boxed Double field to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param value the value of the field
     */
    public static void field(@NonNull WritableSequentialData out, byte[] fieldNameBytes, Double value) {
        if (value == null) {
            fieldNull(out, fieldNameBytes);
        } else {
            field(out, fieldNameBytes, value.doubleValue());
        }
    }

    /**
     * Array field of primitives to JSON string
     *
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param items the items in the array
     * @param <T> the type of the items in the array
     */
    public static <T> void arrayField(@NonNull WritableSequentialData out, byte[] fieldNameBytes, FieldDefinition fieldDefinition, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                out.writeBytes(fieldNameBytes);
                out.writeByte2(OPEN_ARRAY, CLOSE_ARRAY);
            } else {
                out.writeBytes(fieldNameBytes);
                out.writeByte(OPEN_ARRAY);
                boolean isFirst = true;
                for (int i = 0; i < items.size(); i++) {
                    final T item = items.get(i);
                    if (isFirst) {
                        isFirst = false;
                    } else {
                        out.writeByte2(COMMA, SPACE);
                    }
                    if (fieldDefinition.optional() && item == null) {
                        out.writeByte4(n,u,l,l);
                    } else {
                        switch (fieldDefinition.type()) {
                            case STRING -> out.writeJsonString((String) item, true);
                            case BYTES -> {
                                out.writeByte(QUOTE);
                                out.writeBase64((Bytes) item);
                                out.writeByte(QUOTE);
                            }
                            case INT32, SINT32, UINT32, FIXED32, SFIXED32 ->
                                    out.writeJsonLong((Integer) item, false);
                            case INT64, SINT64, UINT64, FIXED64, SFIXED64 ->
                                    out.writeJsonLong((Long) item, true);
                            case FLOAT -> out.writeJsonString(Float.toString((Float) item), false);
                            case DOUBLE -> out.writeJsonString(Double.toString((Double) item), false);
                            case BOOL -> out.writeJsonString(Boolean.toString((Boolean) item), false);
                            case ENUM -> out.writeJsonString(((EnumWithProtoMetadata) item).protoName(), true);
                            case MESSAGE -> throw new UnsupportedOperationException(
                                    "No expected here should have called other arrayField() method");
                            case MAP -> throw new UnsupportedOperationException("Arrays of maps not supported");
                        }
                    }
                }
                out.writeByte(CLOSE_ARRAY);
            }
        }
    }

    /**
     * Array field of objects to JSON string
     *
     * @param indent the indent to use for generated JSON
     * @param fieldNameBytes the name of the field already encoded as bytes
     * @param codec the codec to use for encoding the items
     * @param items the items in the array
     * @param <T> the type of the items in the array
     */
    public static <T> void arrayField(@NonNull WritableSequentialData out, int indent, byte[] fieldNameBytes, JsonCodec<T> codec, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                field(out, fieldNameBytes, "[]");
            } else {
                out.writeBytes(fieldNameBytes);
                out.writeByte(OPEN_ARRAY);
                for (int i = 0; i < items.size(); i++) {
                    var item = items.get(i);
                    codec.write(item, out, indent, 2, false);
                    if (i < items.size() - 1) {
                        out.writeByte2(COMMA, SPACE);
                    }
                }
                out.writeByte(CLOSE_ARRAY);
            }
        }
    }
}
