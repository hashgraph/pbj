package com.hedera.pbj.runtime;

import com.hedera.pbj.runtime.io.ReadableSequentialData;
import com.hedera.pbj.runtime.io.buffer.Bytes;
import com.hedera.pbj.runtime.jsonparser.JSONLexer;
import com.hedera.pbj.runtime.jsonparser.JSONParser;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CodePointBuffer;
import org.antlr.v4.runtime.CodePointCharStream;
import org.antlr.v4.runtime.CommonTokenStream;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.CharBuffer;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Class of static utility methods for working with JSON. All generated JSON is designed to be
 * 100% identical to that generated by Google Protobuf library.
 */
public final class JsonTools {
    /** The indent spacing to use for pretty printing JSON */
    public static final String INDENT = "  ";

    // ====================================================================================================
    // Conversion Utility Methods

    /**
     * Convert a protobuf field name to a protobuf spec json field name. This is based directly on the code
     * from protobuf library so that it matches exactly.
     *
     * @param fieldName the protobuf field name to convert
     * @return the protobuf spec json field name
     */
    public static String toJsonFieldName(String fieldName) {
        // based directly on protoc so output matches
        final int length = fieldName.length();
        StringBuilder result = new StringBuilder(length);
        boolean isNextUpperCase = false;
        for (int i = 0; i < length; i++) {
            char ch = fieldName.charAt(i);
            if (ch == '_') {
                isNextUpperCase = true;
            } else if (isNextUpperCase) {
                // This closely matches the logic for ASCII characters in:
                // http://google3/google/protobuf/descriptor.cc?l=249-251&rcl=228891689
                if ('a' <= ch && ch <= 'z') {
                    ch = (char) (ch - 'a' + 'A');
                }
                result.append(ch);
                isNextUpperCase = false;
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    /**
     * Unescape a string that was escaped by replacing new lines with \n or \r.
     *
     * @param string the string with escapes to unescape
     * @return the unescaped string, null if input string is null
     */
    public static String unescape(@Nullable String string) {
        if (string == null) return null;
        return string.replaceAll("\\\\n", "\n").replaceAll("\\\\r", "\r");
    }

    /**
     * Escape a string by replacing new lines with \n or \r.
     *
     * @param string the string to escape
     * @return the escaped string, null if input string is null
     */
    public static String escape(@Nullable String string) {
        if (string == null) return null;
        return string.replaceAll("\n","\\\\n").replaceAll("\r","\\\\r");
    }

    // ====================================================================================================
    // Parse Methods

    /**
     * Parse a JSON string in a ReadableSequentialData into a JSON object.
     *
     * @param input the ReadableSequentialData containing the JSON string
     * @return the Antlr JSON context object
     * @throws IOException if there was a problem parsing the JSON
     */
    public static JSONParser.ObjContext parseJson(@NonNull final ReadableSequentialData input) throws IOException {
        final JSONLexer lexer = new JSONLexer(CharStreams.fromStream(input.asInputStream()));
        final JSONParser parser = new JSONParser(new CommonTokenStream(lexer));
        final JSONParser.JsonContext jsonContext = parser.json();
        final JSONParser.ValueContext valueContext = jsonContext.value();
        return  valueContext.obj();
    }

    /**
     * Parse a JSON string in a CharBuffer into a JSON object.
     *
     * @param input the CharBuffer containing the JSON string
     * @return the Antlr JSON context object
     */
    public static JSONParser.ObjContext parseJson(@NonNull final CharBuffer input) {
        CodePointBuffer.Builder codePointBufferBuilder = CodePointBuffer.builder(input.remaining());
        codePointBufferBuilder.append(input);
        final JSONLexer lexer = new JSONLexer(CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), "CharBuffer"));
        final JSONParser parser = new JSONParser(new CommonTokenStream(lexer));
        final JSONParser.JsonContext jsonContext = parser.json();
        final JSONParser.ValueContext valueContext = jsonContext.value();
        return  valueContext.obj();
    }

    /**
     * Parse a JSON Object array from a JSONParser.ArrContext into a list of objects.
     *
     * @param arrContext the JSONParser.ArrContext to parse
     * @param codec the JsonCodec to use to parse the objects
     * @return the list of parsed objects
     * @param <T> the type of the objects to parse
     */
    public static <T> List<T> parseObjArray(JSONParser.ArrContext arrContext, JsonCodec<T> codec) {
        return arrContext.value().stream()
                .map(v -> {
                    try {
                        return codec.parse(v.obj(), false);
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                }).toList();
    }

    /**
     * Parse an integer from a JSONParser.ValueContext
     *
     * @param valueContext the JSONParser.ValueContext to parse
     * @return the parsed integer
     */
    public static int parseInteger(JSONParser.ValueContext valueContext) {
        return Integer.parseInt(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    /**
     * Parse a long from a JSONParser.ValueContext
     *
     * @param valueContext the JSONParser.ValueContext to parse
     * @return the parsed long
     */
    public static long parseLong(JSONParser.ValueContext valueContext) {
        return Long.parseLong(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    /**
     * Parse a float from a JSONParser.ValueContext
     *
     * @param valueContext the JSONParser.ValueContext to parse
     * @return the parsed float
     */
    public static float parseFloat(JSONParser.ValueContext valueContext) {
        return Float.parseFloat(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    /**
     * Parse a double from a JSONParser.ValueContext
     *
     * @param valueContext the JSONParser.ValueContext to parse
     * @return the parsed double
     */
    public static double parseDouble(JSONParser.ValueContext valueContext) {
        return Double.parseDouble(valueContext.STRING() != null ? valueContext.STRING().getText() : valueContext.NUMBER().getText());
    }

    /**
     * Parse a boolean from a JSONParser.ValueContext
     *
     * @param valueContext the JSONParser.ValueContext to parse
     * @return the parsed boolean
     */
    public static boolean parseBoolean(JSONParser.ValueContext valueContext) {
        return Boolean.parseBoolean(valueContext.getText());
    }

    // ====================================================================================================
    // To JSON String Methods

    /**
     * Base method for all field to JSON string methods call this with the string for the value.
     *
     * @param fieldName the name of the field
     * @param rawValue the JSON string for value
     * @return the JSON string
     */
    private static String rawFieldCode(String fieldName, String rawValue) {
        return '"' + fieldName + '"' + ": " + rawValue;
    }

    /**
     * Object field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static <T> String field(String indent, String fieldName,
                                 JsonCodec<T> codec, @Nullable final T value) {
        if (value != null) {
            return '"' + toJsonFieldName(fieldName) + '"' + ": " +
                    codec.toJSON(value, indent, true);
        } else {
            return '"' + toJsonFieldName(fieldName) + '"' + ": null";
        }
    }

    /**
     * String field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, String value) {
        return rawFieldCode(fieldName, '"' + escape(value) + '"');
    }

    /**
     * Bytes field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Bytes value) {
        return rawFieldCode(fieldName, '"' + value.toBase64() + '"');
    }

    /**
     * Byte array field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, byte[] value) {
        return rawFieldCode(fieldName, '"' + Base64.getEncoder().encodeToString(value) + '"');
    }

    /**
     * Primitive boolean field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, boolean value) {
        return rawFieldCode(fieldName, value ? "true" : "false");
    }

    /**
     * Primitive int field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, int value) {
        return rawFieldCode(fieldName, Integer.toString(value));
    }

    /**
     * Primitive long field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, long value) {
        return rawFieldCode(fieldName, '"' + Long.toString(value) + '"');
    }

    /**
     * Primitive float field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, float value) {
        if (Float.isNaN(value)) {
            return rawFieldCode(fieldName, "\"NaN\"");
        } else if (Float.isInfinite(value)) {
            return rawFieldCode(fieldName, "\""+(value < 0 ? "-Infinity" : "Infinity")+"\"");
        } else {
            return rawFieldCode(fieldName,  Float.toString(value) );
        }
    }

    /**
     * Primitive double field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, double value) {
        if (Double.isNaN(value)) {
            return rawFieldCode(fieldName, "\"NaN\"");
        } else if (Double.isInfinite(value)) {
            return rawFieldCode(fieldName, "\""+(value < 0 ? "-Infinity" : "Infinity")+"\"");
        } else {
            return rawFieldCode(fieldName, Double.toString(value));
        }
    }

    /**
     * Boxed Boolean field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Boolean value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return rawFieldCode(fieldName, Boolean.toString(value));
        }
    }

    /**
     * Boxed Integer field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Integer value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return rawFieldCode(fieldName, Integer.toString(value));
        }
    }

    /**
     * Boxed Long field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Long value, boolean quote) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else if (quote) {
            return rawFieldCode(fieldName, '\"' + Long.toString(value) + '\"');
        } else {
            return rawFieldCode(fieldName, Long.toString(value));
        }
    }

    /**
     * Boxed Float field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Float value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return field(fieldName, value.floatValue());
        }
    }

    /**
     * Boxed Double field to JSON string
     *
     * @param fieldName the name of the field
     * @param value the value of the field
     * @return the JSON string
     */
    public static String field(String fieldName, Double value) {
        if (value == null) {
            return rawFieldCode(fieldName, "null");
        } else {
            return field(fieldName, value.doubleValue());
        }
    }

    /**
     * Array field of primitives to JSON string
     *
     * @param fieldName the name of the field
     * @param items the items in the array
     * @return the JSON string
     * @param <T> the type of the items in the array
     */
    public static <T> String arrayField(String fieldName,
                                      FieldDefinition fieldDefinition, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                return rawFieldCode(fieldName, "[]");
            } else {
                String values = items.stream()
                        .map(item -> {
                            if (fieldDefinition.optional() && item == null) {
                                return "\"null\"";
                            } else {
                                return switch (fieldDefinition.type()) {
                                    case STRING -> '"' + escape((String) item) + '"';
                                    case BYTES -> '"' + ((Bytes) item).toBase64() + '"';
                                    case INT32, SINT32, UINT32, FIXED32, SFIXED32 -> Integer.toString((Integer) item);
                                    case INT64, SINT64, UINT64, FIXED64, SFIXED64 -> '"' + Long.toString((Long) item) + '"';
                                    case FLOAT -> Float.toString((Float) item);
                                    case DOUBLE -> Double.toString((Double) item);
                                    case BOOL -> Boolean.toString((Boolean) item);
                                    case ENUM -> '"' + ((EnumWithProtoMetadata)item).protoName() + '"';
                                    case MESSAGE -> throw new UnsupportedOperationException("No expected here should have called other arrayField() method");
                                };
                            }
                        })
                        .collect(Collectors.joining(", "));
                return rawFieldCode(fieldName, "["+values+"]");
            }
        }
        return null;
    }

    /**
     * Array field of objects to JSON string
     *
     * @param indent the indent to use for generated JSON
     * @param fieldName the name of the field
     * @param codec the codec to use for encoding the items
     * @param items the items in the array
     * @return the JSON string
     * @param <T> the type of the items in the array
     */
    public static <T> String arrayField(String indent, String fieldName,
                                      JsonCodec<T> codec, List<T> items) {
        if (items != null) {
            if (items.isEmpty()) {
                return rawFieldCode(fieldName, "[]");
            } else {
                StringBuilder code = new StringBuilder('"' + fieldName + '"' + ": [");
                for (int i = 0; i < items.size(); i++) {
                     var item = items.get(i);
                    code.append(codec.toJSON(item, indent, true));
                    if (i < items.size() - 1) {
                        code.append(", ");
                    }
                }
                code.append("]");
                return code.toString();
            }
        }
        return null;
    }

}
